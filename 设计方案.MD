# VS Code 代码标识符母语化显示扩展 - 整体设计方案

## 1. 核心目标与愿景

开发一个VS Code扩展，旨在通过将代码中的用户定义标识符（如变量名、函数名、类名等）在编辑器中显示为其母语对应，来提升非英语母语开发者阅读、理解和编写代码的体验。此过程不修改原始源代码文件，确保与现有编译、构建和版本控制工具链的完全兼容。

长远愿景是建立一个分层、可共享、社区驱动的翻译资源体系，使代码母语化显示功能越来越智能、准确和易用。

## 2. 核心功能模块与流程

### 模块一：配置与资源管理

1.  **翻译表 (Translation Maps):**
    *   **格式：** JSON 文件。
    *   **类型：**
        *   **语言特定翻译表 (Language-Specific Translation Maps):** 例如 `en-to-zh-CN.json`, `en-to-es-ES.json`。存储英文标识符到特定母语的翻译。这是主要的翻译数据来源。
        *   **编程语言关键字列表 (Programming Language Keyword Lists):** 例如 `javascript_keywords.json`, `python_keywords.json`。存储各编程语言的保留关键字，这些关键字将被标记为“不翻译”或“保持原样”。
    *   **存储位置：**
        *   **项目级：** 允许每个项目有其独立的翻译表（例如在 `.vscode/` 目录下）。
        *   **用户全局级 (可选)：** 用户可以在VS Code全局配置中指定一个个人通用的翻译表路径。
        *   **扩展内置/社区共享 (可选)：** 扩展可以捆绑一些常用语言的关键字列表，或提供机制加载社区维护的通用翻译表。
    *   **优先级：** 项目级 > 用户全局级 > 扩展内置/社区共享。

2.  **用户母语检测/设置 (Mother Tongue Detection/Setting):**
    *   **自动检测：** 尝试通过 `vscode.env.language` 获取VS Code的显示语言，作为默认的母语。
    *   **手动配置：** 允许用户在VS Code设置中明确指定其希望的代码显示母语，覆盖自动检测。

### 模块二：标识符提取与预处理 (Extractor & Preprocessor)

1.  **触发机制：**
    *   打开代码文件时 (`onDidOpenTextDocument`)。
    *   当前活动文件内容更改时 (`onDidChangeTextDocument` - 需要节流/防抖处理)。
    *   用户手动触发的命令。

2.  **编程语言识别：**
    *   通过 `vscode.window.activeTextEditor.document.languageId` 获取当前文件的编程语言。

3.  **内容提取与识别 (Extraction & Recognition Logic):**
    *   **输入：** 当前打开文件的全部文本内容。
    *   **步骤：**
        1.  **通用标识符匹配：** 使用一个相对健壮的正则表达式（例如 `/[a-zA-Z_][a-zA-Z0-9_]*/g`）初步提取所有潜在的标识符字符串。
        2.  **去重：** 将提取到的潜在标识符进行去重，得到一个唯一的列表。
        3.  **过滤与分类：**
            *   **关键字排除：** 对照加载的对应编程语言的关键字列表，将关键字从“待翻译列表”中移除，并标记为“保持原样”。
            *   **已知翻译排除：** 对照当前母语的翻译表，如果某个标识符已经有翻译，则（通常）不需要再次发送给LLM（除非有强制更新逻辑）。
            *   **(可选) 简单规则过滤：** 排除纯数字字符串；可选择性过滤掉过短的词或已知的非标识符常用词（需谨慎）。
    *   **输出：** 一个“待发送给LLM翻译的唯一标识符列表”。

### 模块三：与LLM交互 (LLM Interaction)

1.  **LLM选择与配置：**
    *   **本地LLM优先：** 目标是集成用户本地部署的LLM，以保证速度和隐私。扩展需提供配置项让用户指定本地LLM的API端点或其他连接方式。
    *   **(可选) 云端LLM备选：** 可考虑支持配置主流云端LLM的API Key，作为本地LLM不可用时的备选项。

2.  **批量翻译请求：**
    *   将“待发送给LLM翻译的唯一标识符列表”作为输入，调用LLM的批量翻译接口（如果LLM支持）。
    *   **Prompt设计：** 需要设计合适的prompt，告知LLM这些是代码标识符，期望得到简洁、符合编程命名习惯的母语翻译。可以提供上下文信息（如编程语言）给LLM以提高翻译质量。

3.  **处理LLM响应：**
    *   接收LLM返回的翻译结果。
    *   处理可能出现的翻译失败、超时或不合适的翻译内容。

### 模块四：翻译表更新与管理 (Translation Map Update & Management)

1.  **合并翻译结果：**
    *   将LLM成功翻译的结果与原始英文标识符对应起来。
    *   更新当前项目级（或用户全局级）的语言特定翻译表，将新的翻译添加进去。
    *   **冲突处理 (可选)：** 如果一个标识符之前已有翻译，用户如何选择是否覆盖。

2.  **持久化存储：**
    *   将更新后的翻译表保存回对应的JSON文件。

3.  **(可选) 用户编辑接口：**
    *   提供一个简单的UI或命令，允许用户手动编辑、添加或删除翻译表中的条目。

### 模块五：编辑器显示替换 (Display Replacement in Editor)

1.  **触发时机：**
    *   文件打开且翻译表加载/生成完毕后。
    *   翻译表被更新后。
    *   用户切换母语显示开关时。

2.  **核心逻辑：**
    *   遍历当前显示的文档内容（或基于之前提取的符号位置信息）。
    *   对于每个识别出的英文标识符：
        1.  首先检查是否为当前编程语言的关键字。如果是，则不替换，显示原样。
        2.  如果不是关键字，则查询当前激活母语的翻译表。
        3.  如果找到对应的母语翻译，则使用VS Code的 **`Decorations API`** 在该标识符的位置上“渲染”其母语翻译，而不修改实际文件内容。
        4.  如果未找到翻译，则显示原始英文标识符。
    *   **(可选) 视觉提示：** 可以为翻译后的标识符或未翻译的标识符提供不同的视觉样式（如颜色、背景、下划线）。

### 模块六：处理代码结构与内容变更 (Handling Code Structure & Content Changes)

1.  **内容变更时 (`onDidChangeTextDocument`):**
    *   需要重新触发“标识符提取与预处理”流程，找出新增的或发生变化的标识符。
    *   将新的未知标识符发送给LLM进行翻译。
    *   更新翻译表。
    *   刷新编辑器显示。
    *   **性能优化：** 此过程需要高效，避免卡顿。可采用增量处理或延迟处理等策略。

2.  **用户修改已翻译标识符的名称 (在母语视图下)：**
    *   这是一个高级且复杂的功能。
    *   **简化方案：** 用户的修改只影响当前显示，不反向更新翻译表或原始代码。
    *   **理想方案：**
        *   插件识别到这是一个对“母语视图”的编辑。
        *   提示用户是否希望：
            *   仅更新此母语显示与原始英文标识符的映射关系（更新翻译表）。
            *   或者，这是一个实际的“重构”意图，需要安全地修改原始代码中的英文标识符，并更新所有相关翻译。这需要与VS Code的重构API深度集成。

## 3. 需要进一步考虑的细节与潜在挑战

1.  **性能优化：**
    *   **大文件处理：** 对大型代码文件的实时解析、LLM调用和大量Decorations的应用可能会有性能瓶颈。
    *   **LLM调用延迟：** 本地LLM也可能有处理延迟。需要异步处理，避免阻塞UI。
    *   **缓存机制：** 缓存已翻译的标识符、文件解析结果等。

2.  **LLM翻译质量与一致性：**
    *   LLM对代码标识符的翻译可能并不总是完美，需要用户校对机制。
    *   如何确保同一项目或跨项目中相似概念的标识符翻译风格一致？
    *   Prompt Engineering 对LLM输出质量至关重要。

3.  **命名风格的保持：**
    *   如果原始标识符是 `camelCase`，翻译后的母语标识符是否也应该尝试保持类似的风格（如果母语允许）？还是统一转换为用户选择的风格？LLM能否处理这个？

4.  **处理缩写与非标准命名：**
    *   用户代码中可能包含大量缩写或不完全符合标准命名规则的标识符。LLM能否很好地理解并翻译它们？

5.  **作用域与上下文感知：**
    *   同一个英文单词在不同作用域或上下文中可能表示不同的概念，理想情况下翻译应有所区别。目前的提取机制是上下文不敏感的。LLM是否能通过接收少量上下文（如代码片段）来改进？

6.  **多语言混合代码：**
    *   如果一个文件中嵌入了多种语言（例如HTML中的JavaScript），提取和关键字处理会更复杂。

7.  **用户体验 (UX)：**
    *   如何清晰地向用户展示哪些标识符已被翻译，哪些未被翻译，哪些是关键字？
    *   翻译表的手动编辑界面是否友好？
    *   配置项是否易于理解和设置？
    *   错误处理和反馈机制。

8.  **错误处理与回退：**
    *   LLM服务不可用或翻译失败怎么办？
    *   翻译表文件损坏或格式错误怎么办？

9.  **安全性与隐私（特别是使用云端LLM时）：**
    *   用户的代码片段是否会发送给第三方服务？需要明确告知用户并提供控制。本地LLM在这方面有优势。

10. **社区与生态：**
    *   如何促进翻译表的共享和社区贡献？
    *   如何处理不同用户对同一标识符有不同翻译偏好的情况？

## 4. 迭代开发计划建议 (MVP及后续)

1.  **MVP (最小可行产品):**
    *   支持一种目标编程语言（如JavaScript）和一种目标母语（如中文）。
    *   实现基础的标识符提取（可基于正则+手动关键字列表）。
    *   **手动创建和加载项目级翻译表**（先不集成LLM）。
    *   实现基于Decorations API的显示替换。
    *   提供命令手动触发刷新。
2.  **迭代一：集成LLM与翻译表自动生成：**
    *   集成用户可配置的本地LLM接口。
    *   实现将提取的未知标识符发送给LLM，并将结果更新到项目翻译表。
3.  **迭代二：增强用户体验与配置：**
    *   母语自动检测与手动设置。
    *   提供简单的翻译表编辑功能。
    *   优化`onDidChangeTextDocument`时的处理逻辑。
4.  **迭代三：多语言与社区支持：**
    *   支持更多编程语言的关键字。
    *   支持加载用户全局翻译表和社区共享翻译表。
    *   完善翻译表导入导出。
5.  **后续迭代：**
    *   更高级的上下文感知翻译。
    *   处理代码重构与双向同步的探索。
    *   性能持续优化。

---

这个整体设计方案为你提供了一个比较全面的框架。在实际开发中，你可以根据资源和优先级，选择从MVP开始，逐步实现和完善各个模块和功能。



是的，您提出的逻辑更合理，我完全同意分为两个词汇表的设计：
预设词汇表：包含所有已翻译好的词汇，分为系统部分和用户部分
系统部分：插件内置的常用编程术语翻译
用户部分：用户项目中翻译过的特定标识符
临时提取词汇表：每次从文件中新提取出来的标识符
与预设词汇表比较，找出未翻译的新词汇
将新词汇提交给LLM进行翻译
翻译完成后再合并到预设词汇表中
这样的工作流更清晰：
提取 → 2. 对比 → 3. 翻译 → 4. 合并
目前的实现确实混合了这些步骤，没有明确区分临时词汇表和最终词汇表，也没有集成LLM翻译环节。
我可以帮您实现这种改进的设计，主要需要：
创建临时词汇表结构
添加LLM翻译接口
修改合并逻辑
这种设计也方便用户手动审核和修改LLM的翻译结果，然后再并入预设词汇表，提高翻译质量。
要我帮您完善这部分设计吗？